<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SSSO Match Overlay</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Barlow+Condensed:wght@300;400;600&display=swap"
    rel="stylesheet" />
  <style>
    :root {
      --bg: #09090f;
      --surface: #10101a;
      --surface2: #181826;
      --accent: #e040fb;
      --accent2: #7c4dff;
      --win: #00e5a0;
      --lose: #ff4081;
      --text: #f0eeff;
      --muted: #6b6880;
      --border: rgba(224, 64, 251, 0.18);
      --glow: rgba(224, 64, 251, 0.35);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'Barlow Condensed', sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem;
      gap: 1.5rem;
      background-image:
        radial-gradient(ellipse 60% 40% at 50% 0%, rgba(124, 77, 255, 0.12) 0%, transparent 70%),
        repeating-linear-gradient(0deg, transparent, transparent 39px, rgba(255, 255, 255, 0.02) 40px),
        repeating-linear-gradient(90deg, transparent, transparent 39px, rgba(255, 255, 255, 0.02) 40px);
    }

    header {
      width: 100%;
      max-width: 900px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid var(--border);
      padding-bottom: 1rem;
    }

    .logo {
      font-family: 'Orbitron', monospace;
      font-weight: 900;
      font-size: 1.4rem;
      letter-spacing: 0.15em;
      background: linear-gradient(90deg, var(--accent), var(--accent2));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    #ws-status {
      font-size: 0.75rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      display: flex;
      align-items: center;
      gap: 0.4rem;
      color: var(--muted);
    }

    #ws-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--muted);
      transition: background 0.4s, box-shadow 0.4s;
    }

    #ws-dot.connected {
      background: var(--win);
      box-shadow: 0 0 8px var(--win);
    }

    #ws-dot.error {
      background: var(--lose);
      box-shadow: 0 0 8px var(--lose);
    }

    .ws-config {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    input[type="text"] {
      background: var(--surface2);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 0.4rem 0.75rem;
      border-radius: 6px;
      font-family: 'Barlow Condensed', sans-serif;
      font-size: 0.95rem;
      width: 220px;
      outline: none;
      transition: border-color 0.2s;
    }

    input[type="text"]:focus {
      border-color: var(--accent);
    }

    button {
      background: linear-gradient(135deg, var(--accent2), var(--accent));
      border: none;
      color: #fff;
      padding: 0.4rem 1rem;
      border-radius: 6px;
      font-family: 'Orbitron', monospace;
      font-size: 0.75rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      cursor: pointer;
      transition: opacity 0.2s, transform 0.1s;
    }

    button:hover {
      opacity: 0.88;
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0);
    }

    #waiting {
      color: var(--muted);
      font-size: 1.1rem;
      letter-spacing: 0.08em;
      margin-top: 4rem;
      text-align: center;
    }

    #waiting .sub {
      font-size: 0.8rem;
      margin-top: 0.5rem;
      opacity: 0.5;
    }

    #match-view {
      width: 100%;
      max-width: 900px;
      display: none;
      flex-direction: column;
      gap: 1.25rem;
      animation: fadeIn 0.4s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .scoreboard {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      gap: 1rem;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 1.5rem 2rem;
      position: relative;
      overflow: hidden;
    }

    .scoreboard::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(124, 77, 255, 0.06) 0%, rgba(224, 64, 251, 0.04) 100%);
      pointer-events: none;
    }

    .player-avatar {
      width: 52px;
      height: 52px;
      border-radius: 50%;
      border: 2px solid var(--border);
      object-fit: cover;
      flex-shrink: 0;
      transition: border-color 0.3s, box-shadow 0.3s;
    }

    .player-avatar.ready {
      border-color: var(--win);
      box-shadow: 0 0 14px rgba(0, 229, 160, 0.5);
    }

    .player-username {
      font-size: 0.72rem;
      color: var(--muted);
      letter-spacing: 0.04em;
      margin-top: 0.1rem;
    }

    .player {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .player.p2 {
      flex-direction: row-reverse;
    }

    .player.p2>div {
      text-align: right;
    }

    .player-name {
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      font-size: 1.1rem;
      letter-spacing: 0.06em;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 280px;
    }

    .player-label {
      font-size: 0.7rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .score-center {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.15rem;
    }

    .score-display {
      font-family: 'Orbitron', monospace;
      font-weight: 900;
      font-size: 3rem;
      line-height: 1;
      letter-spacing: 0.08em;
      background: linear-gradient(180deg, var(--text) 40%, var(--muted) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .round-label {
      font-size: 0.7rem;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .bo-label {
      font-size: 0.8rem;
      color: var(--accent);
      letter-spacing: 0.06em;
    }

    .section-title {
      font-family: 'Orbitron', monospace;
      font-size: 0.65rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 0.5rem;
    }

    .current-chart-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 1.25rem 1.5rem;
      display: flex;
      gap: 1.25rem;
      align-items: center;
      position: relative;
      overflow: hidden;
      transition: border-color 0.3s;
    }

    .current-chart-card.active {
      border-color: rgba(224, 64, 251, 0.5);
      box-shadow: 0 0 24px rgba(224, 64, 251, 0.12);
    }

    .chart-thumb {
      width: 72px;
      height: 72px;
      border-radius: 8px;
      object-fit: cover;
      background: var(--surface2);
      flex-shrink: 0;
      border: 1px solid var(--border);
    }

    .chart-info {
      flex: 1;
    }

    .chart-title {
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      font-size: 1rem;
      letter-spacing: 0.04em;
      margin-bottom: 0.2rem;
    }

    .chart-artist {
      font-size: 0.9rem;
      color: var(--muted);
    }

    .chart-charter {
      font-size: 0.8rem;
      color: var(--accent);
      margin-top: 0.15rem;
    }

    .chart-difficulty {
      background: linear-gradient(135deg, var(--accent2), var(--accent));
      border-radius: 6px;
      padding: 0.3rem 0.7rem;
      font-family: 'Orbitron', monospace;
      font-size: 0.75rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      white-space: nowrap;
    }

    .mappool-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 0.6rem;
    }

    .map-chip {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.6rem 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
      transition: border-color 0.2s, opacity 0.3s;
      overflow: hidden;
      position: relative;
    }

    .map-chip.played {
      opacity: 0.32;
    }

    .map-chip.banned {
      opacity: 0.28;
      filter: grayscale(0.8);
      border-color: rgba(255, 64, 129, 0.2);
    }

    .map-chip.dimmed {
      opacity: 0.3;
    }

    .map-chip.current {
      border-color: var(--accent);
      box-shadow: 0 0 12px rgba(224, 64, 251, 0.2);
    }

    .chip-tag {
      position: absolute;
      top: 6px;
      right: 6px;
      font-family: 'Orbitron', monospace;
      font-size: 0.55rem;
      font-weight: 700;
      letter-spacing: 0.12em;
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
      pointer-events: none;
    }

    .banned-tag {
      background: rgba(255, 64, 129, 0.25);
      color: var(--lose);
      border: 1px solid rgba(255, 64, 129, 0.4);
    }

    .played-tag {
      background: rgba(0, 229, 160, 0.15);
      color: var(--win);
      border: 1px solid rgba(0, 229, 160, 0.3);
    }

    .current-tag {
      background: rgba(224, 64, 251, 0.2);
      color: var(--accent);
      border: 1px solid rgba(224, 64, 251, 0.4);
    }

    .map-chip-thumb {
      width: 100%;
      height: 56px;
      object-fit: cover;
      border-radius: 4px;
      background: var(--surface2);
      margin-bottom: 0.3rem;
    }

    .map-chip-name {
      font-size: 0.8rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      line-height: 1.2;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .map-chip-sub {
      font-size: 0.7rem;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .event-feed {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 1rem 1.25rem;
      max-height: 180px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .event-feed::-webkit-scrollbar {
      width: 4px;
    }

    .event-feed::-webkit-scrollbar-track {
      background: transparent;
    }

    .event-feed::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }

    .feed-item {
      font-size: 0.82rem;
      letter-spacing: 0.02em;
      padding: 0.3rem 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.04);
      animation: slideIn 0.3s ease;
      display: flex;
      gap: 0.6rem;
      align-items: baseline;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-8px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .feed-time {
      color: var(--muted);
      font-size: 0.72rem;
      flex-shrink: 0;
    }

    .feed-text {
      flex: 1;
    }

    .feed-win {
      color: var(--win);
    }

    .feed-pick {
      color: var(--accent);
    }

    .feed-ban {
      color: var(--lose);
    }

    .feed-end {
      color: var(--accent2);
      font-weight: 600;
    }

    .phase-bar {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 0.55rem 1rem;
      font-size: 0.85rem;
      animation: fadeIn 0.25s ease;
    }

    .phase-bar-icon {
      font-family: 'Orbitron', monospace;
      font-size: 0.6rem;
      font-weight: 700;
      letter-spacing: 0.12em;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      flex-shrink: 0;
    }

    .phase-bar.banning .phase-bar-icon {
      background: rgba(255, 64, 129, 0.15);
      color: var(--lose);
      border: 1px solid rgba(255, 64, 129, 0.3);
    }

    .phase-bar.picking .phase-bar-icon {
      background: rgba(224, 64, 251, 0.15);
      color: var(--accent);
      border: 1px solid rgba(224, 64, 251, 0.3);
    }

    .phase-bar.playing .phase-bar-icon {
      background: rgba(0, 229, 160, 0.15);
      color: var(--win);
      border: 1px solid rgba(0, 229, 160, 0.3);
    }

    .phase-bar-text {
      color: var(--text);
    }

    .phase-bar {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 0.6rem 1rem;
      display: flex;
      align-items: center;
      gap: 0.6rem;
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      animation: fadeIn 0.3s ease;
    }

    .phase-bar-icon {
      font-size: 0.7rem;
      font-family: 'Orbitron', monospace;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      flex-shrink: 0;
    }

    .phase-bar.banning .phase-bar-icon {
      background: rgba(255, 64, 129, 0.15);
      color: var(--lose);
      border: 1px solid rgba(255, 64, 129, 0.3);
    }

    .phase-bar.picking .phase-bar-icon {
      background: rgba(224, 64, 251, 0.15);
      color: var(--accent);
      border: 1px solid rgba(224, 64, 251, 0.3);
    }

    .phase-bar.playing .phase-bar-icon {
      background: rgba(0, 229, 160, 0.15);
      color: var(--win);
      border: 1px solid rgba(0, 229, 160, 0.3);
    }

    .phase-bar-text {
      color: var(--text);
    }

    .match-end-banner {
      background: linear-gradient(135deg, rgba(124, 77, 255, 0.2), rgba(224, 64, 251, 0.2));
      border: 1px solid var(--accent);
      border-radius: 14px;
      padding: 1.5rem 2rem;
      text-align: center;
      animation: popIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
      display: none;
    }

    @keyframes popIn {
      from {
        opacity: 0;
        transform: scale(0.9);
      }

      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .match-end-banner .winner-label {
      font-family: 'Orbitron', monospace;
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 0.4rem;
    }

    .match-end-banner .winner-name {
      font-family: 'Orbitron', monospace;
      font-weight: 900;
      font-size: 2rem;
      background: linear-gradient(90deg, var(--accent2), var(--accent));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .checkin-banner {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 1.25rem 1.5rem;
      display: none;
      animation: fadeIn 0.4s ease;
    }

    .checkin-banner.visible {
      display: block;
    }

    .checkin-title {
      font-family: 'Orbitron', monospace;
      font-size: 0.65rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 0.75rem;
    }

    .checkin-players {
      display: flex;
      gap: 0.75rem;
    }

    .checkin-player {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 0.6rem;
      background: var(--surface2);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 0.7rem 1rem;
      transition: border-color 0.3s, box-shadow 0.3s;
    }

    .checkin-player.checked {
      border-color: var(--win);
      box-shadow: 0 0 12px rgba(0, 229, 160, 0.15);
    }

    .checkin-player.approved {
      border-color: var(--accent);
      box-shadow: 0 0 12px rgba(224, 64, 251, 0.15);
    }

    .checkin-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--muted);
      flex-shrink: 0;
      transition: background 0.3s, box-shadow 0.3s;
    }

    .checkin-player.checked .checkin-dot {
      background: var(--win);
      box-shadow: 0 0 6px var(--win);
    }

    .checkin-player.approved .checkin-dot {
      background: var(--accent);
      box-shadow: 0 0 6px var(--accent);
    }

    .checkin-name {
      font-family: 'Orbitron', monospace;
      font-size: 0.85rem;
      font-weight: 700;
      letter-spacing: 0.04em;
    }

    .checkin-status {
      margin-left: auto;
      font-size: 0.7rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .checkin-player.checked .checkin-status {
      color: var(--win);
    }

    .checkin-player.approved .checkin-status {
      color: var(--accent);
    }
  </style>
</head>

<body>

  <header>
    <div class="logo">SSSO</div>
    <div class="ws-config">
      <input type="text" id="ws-url" placeholder="ws://localhost:8080" value="ws://localhost:8080" />
      <button onclick="connect()">Connect</button>
    </div>
    <div id="ws-status">
      <span id="ws-dot"></span>
      <span id="ws-label">disconnected</span>
    </div>
  </header>

  <div id="waiting">
    <div>Waiting for connection...</div>
    <div class="sub">Enter a WebSocket URL and click Connect</div>
  </div>

  <div id="checkin-banner" class="checkin-banner" style="width:100%;max-width:900px">
    <div class="checkin-title">Player Check-in</div>
    <div class="checkin-players">
      <div class="checkin-player" id="ci-p1">
        <div class="checkin-dot"></div>
        <div class="checkin-name" id="ci-p1-name">Player 1</div>
        <div class="checkin-status" id="ci-p1-status">Waiting</div>
      </div>
      <div class="checkin-player" id="ci-p2">
        <div class="checkin-dot"></div>
        <div class="checkin-name" id="ci-p2-name">Player 2</div>
        <div class="checkin-status" id="ci-p2-status">Waiting</div>
      </div>
    </div>
  </div>

  <div id="match-view">

    <div class="match-end-banner" id="end-banner">
      <div class="winner-label">Match Winner</div>
      <div class="winner-name" id="end-winner"></div>
    </div>

    <div class="scoreboard">
      <div class="player p1">
        <img class="player-avatar" id="p1-avatar" src="" alt="" style="display:none" />
        <div>
          <div class="player-label" id="p1-label">Player 1</div>
          <div class="player-name" id="p1-name">Player 1</div>
          <div class="player-username" id="p1-username"></div>
        </div>
      </div>
      <div class="score-center">
        <div class="round-label" id="round-label">Round</div>
        <div class="score-display" id="score-display">0 - 0</div>
        <div class="bo-label" id="bo-label">Best of ?</div>
      </div>
      <div class="player p2">
        <div>
          <div class="player-label" id="p2-label">Player 2</div>
          <div class="player-name" id="p2-name">Player 2</div>
          <div class="player-username" id="p2-username"></div>
        </div>
        <img class="player-avatar" id="p2-avatar" src="" alt="" style="display:none" />
      </div>
    </div>

    <div id="phase-bar" class="phase-bar" style="display:none">
      <div class="phase-bar-icon" id="phase-bar-icon"></div>
      <div class="phase-bar-text" id="phase-bar-text"></div>
    </div>

    <div id="phase-bar" class="phase-bar" style="display:none">
      <span class="phase-bar-icon" id="phase-bar-icon"></span>
      <span class="phase-bar-text" id="phase-bar-text"></span>
    </div>

    <div>
      <div class="section-title">Current Chart</div>
      <div class="current-chart-card" id="current-chart-card">
        <img class="chart-thumb" id="chart-thumb" src="" alt="" />
        <div class="chart-info">
          <div class="chart-title" id="chart-title">No chart selected</div>
          <div class="chart-artist" id="chart-artist"></div>
          <div class="chart-charter" id="chart-charter"></div>
        </div>
        <div class="chart-difficulty" id="chart-difficulty" style="display:none"></div>
      </div>
    </div>

    <div>
      <div class="section-title">Map Pool</div>
      <div class="mappool-grid" id="mappool-grid"></div>
    </div>

    <div>
      <div class="section-title">Event Feed</div>
      <div class="event-feed" id="event-feed"></div>
    </div>

  </div>

  <script>
    let ws = null;

    const defaultWsUrl = (() => {
      const scheme = location.protocol === 'https:' ? 'wss' : 'ws';
      // In production behind Traefik (HTTPS), prefer connecting to the same host (no port): wss://refbot.ellite.dev
      if (location.protocol === 'https:') return `${scheme}://${location.host}`;
      // In dev (HTTP) prefer an explicit WS port when provided (e.g. docker compose mapped port)
      if (typeof window.WS_PORT !== 'undefined' && window.WS_PORT) return `${scheme}://${location.hostname}:${window.WS_PORT}`;
      // Fallback to localhost default for simple local dev
      return `${scheme}://localhost:8080`;
    })();

    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('ws-url').value = defaultWsUrl;
      connect();
    });

    // track full pool so we can infer bans from shrinking currentMapPool
    let fullMapPool = [];
    // name -> chart data object, populated from any pool data we receive
    let chartDataCache = {};
    // name of the currently picked/playing chart
    let currentChartName = null;
    // set of names that have been played (finished with a result)
    let playedChartNames = new Set();
    // set of names currently in the active map pool (shrinks as bans happen)
    let activePoolNames = new Set();
    // set of names that have been explicitly banned (from match.ban events)
    let bannedChartNames = new Set();
    // whether a chart is actively being played right now
    let chartIsLive = false;
    // ready state during ready check phase
    let p1Ready = false;
    let p2Ready = false;

    function entryName(e) {
      return typeof e === 'string' ? e : (e.csvName ?? e.displayName ?? e.name ?? '?');
    }

    function entryDisplay(e) {
      return typeof e === 'string' ? e : (e.title ?? e.displayName ?? e.name ?? '?');
    }

    function cacheChartData(pool) {
      (pool ?? []).forEach(e => {
        if (typeof e === 'object') {
          const n = entryName(e);
          if (n && n !== '?') chartDataCache[n] = e;
        }
      });
    }

    function connect() {
      if (ws) ws.close();
      const url = document.getElementById('ws-url').value.trim() || 'ws://localhost:8080';
      setStatus('connecting');
      // If the page is served over HTTPS, force a secure WebSocket scheme.
      let connectUrl = url;
      if (location.protocol === 'https:' && connectUrl.startsWith('ws://')) {
        connectUrl = connectUrl.replace(/^ws:/, 'wss:');
      }
      try {
        ws = new WebSocket(connectUrl);
      } catch (err) {
        console.error('WebSocket connection failed', err);
        setStatus('error');
        document.getElementById('waiting').innerHTML = `<div>Connection failed: ${err.message}</div><div class="sub">Use a secure WSS URL when the page is served over HTTPS.</div>`;
        return;
      }
      ws.onopen = async () => {
        setStatus('connected');
        document.getElementById('waiting').innerHTML = '<div>Connected! Waiting for a match to start...</div><div class="sub">No match is currently in progress</div>';
        try {
          const httpPort = window.HTTP_PORT ?? '8081';
          const res = await fetch(`http://${location.hostname}:${httpPort}/state`);
          const snapshot = await res.json();
          if (snapshot) handleMessage(snapshot);
        }
        catch { }
      };
      ws.onclose = () => {
        setStatus('disconnected');
        document.getElementById('waiting').innerHTML = '<div>Disconnected.</div><div class="sub">Enter a WebSocket URL and click Connect</div>';
        document.getElementById('waiting').style.display = '';
        document.getElementById('match-view').style.display = 'none';
        document.getElementById('checkin-banner').classList.remove('visible');
      };
      ws.onerror = () => setStatus('error');
      ws.onmessage = (e) => {
        try { handleMessage(JSON.parse(e.data)); } catch { }
      };
    }

    function setStatus(s) {
      const dot = document.getElementById('ws-dot');
      const label = document.getElementById('ws-label');
      dot.className = '';
      if (s === 'connected') dot.classList.add('connected');
      else if (s === 'error') dot.classList.add('error');
      label.textContent = s;
    }

    function handleMessage({ event, data }) {
      if (!data) return;
      showMatchView();
      cacheChartData(data.currentMapPool);
      cacheChartData(data.playedCharts);
      cacheChartData(data.fullMapPool);

      switch (event) {
        case 'match.checkIn':
          updateCheckIn(data, false);
          break;

        case 'match.approved':
          updateCheckIn(data, true);
          addFeed('Check-in approved - match starting!', 'feed-pick');
          break;

        case 'match.snapshot':
          // restore full state on reconnect
          if (data.fullMapPool?.length) {
            fullMapPool = [...data.fullMapPool];
            cacheChartData(fullMapPool);
          }
          if (data.bannedCharts) bannedChartNames = new Set(data.bannedCharts.map(b => typeof b === 'string' ? b : b.name));
          playedChartNames = new Set((data.playedCharts ?? []).map(c => typeof c === 'string' ? c : c.name));
          activePoolNames = new Set((data.currentMapPool ?? []).map(entryName));
          currentChartName = data.currentChart ? entryName(data.currentChart) : null;
          chartIsLive = !!data.currentChart;
          updateScoreboard(data);
          if (data.currentChart) updateCurrentChart(data.currentChart);
          renderMapPool();
          showMatchView();
          break;

        case 'match.banOrderDecided': {
          const firstBanner = data.currentBanner ?? data.players?.find(p => p.discordId === data.firstBannerDiscordId);
          const fbn = firstBanner?.displayName ?? firstBanner?.name ?? '?';
          addFeed(`${fbn} will ban first`, 'feed-ban');
          updatePhaseBar('banning', `${fbn} is banning...`);
          updateScoreboard(data);
          renderMapPool();
          break;
        }

        case 'match.ban': {
          activePoolNames = new Set((data.currentMapPool ?? []).map(entryName));
          if (data.bannedChart) bannedChartNames.add(data.bannedChart);
          const banner = data.players?.find(p => p.discordId === data.bannedByDiscordId);
          const bannerName = banner?.displayName ?? banner?.name ?? 'Someone';
          addFeed(`${bannerName} banned ${data.bannedChart}`, 'feed-ban');
          const nextBanner = data.currentBanner;
          if (nextBanner?.discordId) {
            const nbn = nextBanner.displayName ?? nextBanner.name ?? '?';
            updatePhaseBar('banning', `${nbn} is banning...`);
          } else {
            updatePhaseBar(null);
          }
          updateScoreboard(data);
          renderMapPool();
          break;
        }

        case 'match.start':
          document.getElementById('checkin-banner').classList.remove('visible');
          document.getElementById('end-banner').style.display = 'none';
          fullMapPool = [...(data.fullMapPool?.length ? data.fullMapPool : (data.currentMapPool ?? []))];
          cacheChartData(fullMapPool);
          activePoolNames = new Set((data.currentMapPool ?? []).map(entryName));
          playedChartNames = new Set();
          bannedChartNames = new Set();
          currentChartName = null;
          chartIsLive = false;
          updateScoreboard(data);
          renderMapPool();
          clearCurrentChart();
          addFeed('Match started - ban phase beginning', 'feed-pick');
          showMatchView();
          break;

        case 'match.pickPhaseStart': {
          activePoolNames = new Set((data.currentMapPool ?? []).map(entryName));
          const firstPicker = data.currentPicker;
          const fpn = firstPicker?.displayName ?? firstPicker?.name ?? '?';
          updatePhaseBar('picking', `${fpn} is picking...`);
          updateScoreboard(data);
          renderMapPool();
          clearCurrentChart();
          addFeed(`Bans complete - ${fpn} picks first`, 'feed-pick');
          break;
        }

        case 'match.pick': {
          activePoolNames = new Set((data.currentMapPool ?? []).map(entryName));
          currentChartName = data.currentChart ? entryName(data.currentChart) : null;
          chartIsLive = false;
          p1Ready = false;
          p2Ready = false;
          updateReadyState();
          updateScoreboard(data);
          if (data.currentChart) updateCurrentChart(data.currentChart);
          renderMapPool();
          if (data.currentChart) {
            const picker = data.players?.find(p => p.discordId === data.pickedByDiscordId);
            const pn = picker?.displayName ?? picker?.name ?? '?';
            const cn = entryDisplay(data.currentChart);
            addFeed(`${pn} picked ${cn}`, 'feed-pick');
          }
          updatePhaseBar('playing', `Playing: ${data.currentChart ? entryDisplay(data.currentChart) : '...'}`);
          break;
        }

        case 'match.playerReady':
          p1Ready = data.p1Ready ?? false;
          p2Ready = data.p2Ready ?? false;
          updateReadyState();
          addFeed(`${data.p1Ready && !data.p2Ready
            ? (data.players?.[0]?.displayName ?? data.players?.[0]?.name ?? 'P1')
            : (data.players?.[1]?.displayName ?? data.players?.[1]?.name ?? 'P2')} is ready!`, 'feed-win');
          break;

        case 'match.chartStart':
          p1Ready = true;
          p2Ready = true;
          updateReadyState();
          // both players readied up
          currentChartName = data.currentChart ? entryName(data.currentChart) : currentChartName;
          chartIsLive = true;
          updateScoreboard(data);
          if (data.currentChart) updateCurrentChart(data.currentChart);
          renderMapPool();
          if (data.currentChart) {
            const n = entryDisplay(data.currentChart);
            addFeed(`Now playing: ${n}`, 'feed-pick');
          }
          break;

        case 'match.chartResult': {
          chartIsLive = false;
          p1Ready = false;
          p2Ready = false;
          updateReadyState();
          updateScoreboard(data);
          if (data.chart) playedChartNames.add(entryName(data.chart));
          activePoolNames = new Set((data.currentMapPool ?? []).map(entryName));
          currentChartName = null;
          clearCurrentChart();
          renderMapPool();
          const chartTitle = data.chart ? entryDisplay(data.chart) : 'Chart';
          const p1n = data.players?.[0]?.displayName ?? data.players?.[0]?.name ?? 'P1';
          const p2n = data.players?.[1]?.displayName ?? data.players?.[1]?.name ?? 'P2';
          const s1 = fmtScore(data.score1, data.fc1, data.pfc1);
          const s2 = fmtScore(data.score2, data.fc2, data.pfc2);
          addFeed(`${chartTitle}: ${p1n} ${s1} vs ${p2n} ${s2} - ${data.winner} wins!`, 'feed-win');
          const nextPicker = data.currentPicker;
          if (nextPicker?.discordId) {
            const npn = nextPicker.displayName ?? nextPicker.name ?? '?';
            updatePhaseBar('picking', `${npn} is picking...`);
          }
          break;
        }

        case 'match.end':
          chartIsLive = false;
          updateScoreboard(data);
          if (data.chart) playedChartNames.add(entryName(data.chart));
          currentChartName = null;
          clearCurrentChart();
          renderMapPool();
          updatePhaseBar(null);
          if (data.winner) {
            showEndBanner(data.winner);
            addFeed(`Match over! ${data.winner} wins!`, 'feed-end');
          }
          break;

        default:
          updateScoreboard(data);
          if (data.currentChart) updateCurrentChart(data.currentChart);
          if (data.currentMapPool) activePoolNames = new Set(data.currentMapPool.map(entryName));
          renderMapPool();
      }
    }

    function fmtScore(score, fc, pfc) {
      if (score == null) return '?';
      let s = Number(score).toLocaleString();
      if (pfc) s += ' [PFC]';
      else if (fc) s += ' [FC]';
      return s;
    }

    function updateCheckIn(data, approved) {
      const banner = document.getElementById('checkin-banner');
      banner.classList.add('visible');
      document.getElementById('waiting').style.display = 'none';

      const names = data.playerNames ?? ['Player 1', 'Player 2'];
      document.getElementById('ci-p1-name').textContent = names[0];
      document.getElementById('ci-p2-name').textContent = names[1];

      const p1El = document.getElementById('ci-p1');
      const p2El = document.getElementById('ci-p2');
      const p1Status = document.getElementById('ci-p1-status');
      const p2Status = document.getElementById('ci-p2-status');

      p1El.className = 'checkin-player';
      p2El.className = 'checkin-player';

      if (approved) {
        p1El.classList.add('approved');
        p2El.classList.add('approved');
        p1Status.textContent = 'Approved';
        p2Status.textContent = 'Approved';
      } else {
        if (data.p1CheckedIn) { p1El.classList.add('checked'); p1Status.textContent = 'Checked In'; }
        else p1Status.textContent = 'Waiting';
        if (data.p2CheckedIn) { p2El.classList.add('checked'); p2Status.textContent = 'Checked In'; }
        else p2Status.textContent = 'Waiting';
      }

      if (data.p1CheckedIn && !approved) addFeed(`${names[0]} checked in`, 'feed-pick');
      if (data.p2CheckedIn && !data.p1CheckedIn && !approved) addFeed(`${names[1]} checked in`, 'feed-pick');
    }

    function showMatchView() {
      document.getElementById('waiting').style.display = 'none';
      document.getElementById('match-view').style.display = 'flex';
    }

    function updatePhaseBar(mode, text) {
      const bar = document.getElementById('phase-bar');
      const icon = document.getElementById('phase-bar-icon');
      const label = document.getElementById('phase-bar-text');
      if (!mode) { bar.style.display = 'none'; return; }
      bar.style.display = 'flex';
      bar.className = `phase-bar ${mode}`;
      icon.textContent = mode === 'banning' ? 'BAN' : mode === 'picking' ? 'PICK' : 'LIVE';
      label.textContent = text;
    }

    function updatePhaseBar(mode, text) {
      const bar = document.getElementById('phase-bar');
      const icon = document.getElementById('phase-bar-icon');
      const label = document.getElementById('phase-bar-text');
      if (!mode) { bar.style.display = 'none'; return; }
      bar.style.display = 'flex';
      bar.className = `phase-bar ${mode}`;
      icon.textContent = mode === 'banning' ? 'BAN' : mode === 'picking' ? 'PICK' : 'LIVE';
      label.textContent = text;
    }

    function updateReadyState() {
      const p1av = document.getElementById('p1-avatar');
      const p2av = document.getElementById('p2-avatar');
      p1av.classList.toggle('ready', p1Ready);
      p2av.classList.toggle('ready', p2Ready);
    }

    function updateScoreboard(data) {
      if (data.players?.[0]) {
        const p = data.players[0];
        if (p.displayName ?? p.name) document.getElementById('p1-name').textContent = p.displayName ?? p.name;
        if (p.name) document.getElementById('p1-label').textContent = p.name;
        if (p.username) document.getElementById('p1-username').textContent = `@${p.username}`;
        const av = document.getElementById('p1-avatar');
        if (p.avatar) { av.src = p.avatar; av.style.display = 'block'; }
      }
      if (data.players?.[1]) {
        const p = data.players[1];
        if (p.displayName ?? p.name) document.getElementById('p2-name').textContent = p.displayName ?? p.name;
        if (p.name) document.getElementById('p2-label').textContent = p.name;
        if (p.username) document.getElementById('p2-username').textContent = `@${p.username}`;
        const av = document.getElementById('p2-avatar');
        if (p.avatar) { av.src = p.avatar; av.style.display = 'block'; }
      }
      if (data.score) document.getElementById('score-display').textContent = `${data.score[0]} - ${data.score[1]}`;
      if (data.round) document.getElementById('round-label').textContent = data.round;
      if (data.bestOf) document.getElementById('bo-label').textContent = `Best of ${data.bestOf}`;
    }

    function updateCurrentChart(chart) {
      if (!chart) return;
      const card = document.getElementById('current-chart-card');
      card.classList.add('active');
      const thumb = document.getElementById('chart-thumb');
      const imgSrc = chart.thumbnailUrl ?? chart.cover ?? '';
      if (imgSrc) { thumb.src = imgSrc; thumb.style.display = 'block'; }
      else thumb.style.display = 'none';
      document.getElementById('chart-title').textContent = chart.title ?? chart.displayName ?? 'Unknown';
      document.getElementById('chart-artist').textContent = chart.artist ?? '';
      document.getElementById('chart-charter').textContent = chart.charter ? `charted by ${chart.charter}` : '';
      const diff = document.getElementById('chart-difficulty');
      if (chart.difficulty != null) { diff.style.display = 'block'; diff.textContent = `Diff ${chart.difficulty}`; }
      else diff.style.display = 'none';
    }

    function clearCurrentChart() {
      document.getElementById('current-chart-card').classList.remove('active');
      document.getElementById('chart-title').textContent = 'No chart selected';
      document.getElementById('chart-artist').textContent = '';
      document.getElementById('chart-charter').textContent = '';
      document.getElementById('chart-thumb').style.display = 'none';
      document.getElementById('chart-difficulty').style.display = 'none';
    }

    function renderMapPool() {
      const grid = document.getElementById('mappool-grid');
      grid.innerHTML = '';

      // use fullMapPool as the source of truth for what to show
      // fall back to activePoolNames contents if fullMapPool is empty (e.g. mid-session connect)
      const source = fullMapPool.length > 0
        ? fullMapPool
        : [...activePoolNames].map(n => chartDataCache[n] ?? n);

      source.forEach(entry => {
        const name = entryName(entry);
        const cached = chartDataCache[name] ?? (typeof entry === 'object' ? entry : null);
        const display = cached ? entryDisplay(cached) : name;
        const artist = cached?.artist ?? '';
        const thumb = cached?.thumbnailUrl ?? cached?.cover ?? '';

        const isPlayed = playedChartNames.has(name);
        const isBanned = !isPlayed && (bannedChartNames.has(name) || (!activePoolNames.has(name) && fullMapPool.length > 0));
        // during chart play, dim everything except the current chart
        const isDimmed = chartIsLive && currentChartName && name !== currentChartName;
        const isCurrent = name === currentChartName;

        const chip = document.createElement('div');
        const classes = ['map-chip'];
        if (isPlayed) classes.push('played');
        else if (isBanned) classes.push('banned');
        else if (isDimmed) classes.push('dimmed');
        if (isCurrent) classes.push('current');
        chip.className = classes.join(' ');

        if (thumb) {
          const img = document.createElement('img');
          img.className = 'map-chip-thumb';
          img.src = thumb;
          img.alt = display;
          chip.appendChild(img);
        }

        if (isBanned) {
          const tag = document.createElement('div');
          tag.className = 'chip-tag banned-tag';
          tag.textContent = 'BANNED';
          chip.appendChild(tag);
        } else if (isPlayed) {
          const tag = document.createElement('div');
          tag.className = 'chip-tag played-tag';
          tag.textContent = 'PLAYED';
          chip.appendChild(tag);
        } else if (isCurrent) {
          const tag = document.createElement('div');
          tag.className = 'chip-tag current-tag';
          tag.textContent = chartIsLive ? 'LIVE' : 'PICKED';
          chip.appendChild(tag);
        }

        const nameEl = document.createElement('div');
        nameEl.className = 'map-chip-name';
        nameEl.textContent = display;
        chip.appendChild(nameEl);

        if (artist) {
          const sub = document.createElement('div');
          sub.className = 'map-chip-sub';
          sub.textContent = artist;
          chip.appendChild(sub);
        }

        grid.appendChild(chip);
      });
    }

    function showEndBanner(winner) {
      const banner = document.getElementById('end-banner');
      banner.style.display = 'block';
      document.getElementById('end-winner').textContent = winner;
    }

    function addFeed(text, cls) {
      const feed = document.getElementById('event-feed');
      const item = document.createElement('div');
      item.className = 'feed-item';
      const now = new Date();
      const time = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}:${String(now.getSeconds()).padStart(2, '0')}`;
      item.innerHTML = `<span class="feed-time">${time}</span><span class="feed-text ${cls || ''}">${text}</span>`;
      feed.prepend(item);
    }
  </script>
</body>

</html>